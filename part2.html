<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Часть 2</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Tiny5&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <style>
        /* Ладно, добавлю сюда ещё один css потому что лень использовать уже готовый в отдельном файле. надеюсь я туда не много напишу. будущий я скажи "я тебя люблю" если я был прав СУКА Я ТЕБЯ НЕНАВИЖУ ТЫ ОБОСРАННОЕ ЖИВОТНОЕ ЗАЧЕМ ТЫ ЭТО СДЕЛАЛО ПРИВЕТ С БУДУЩЕГО СУКА НУ НАХЕР СКАЖИ НАХЕР ТЫ ЭТО СДЕЛАЛ НАХЕР ТЫ СУКА СДЕЛАЛ ДОПОЛНИТЕЛЬНЫЙ СТАЙЛКСС КОГДА У ТЕБЯ УЖЕ ЕСТЬ СУЩЕСТВУЮЩИЙ БОЖЕ Я ТЕБЯ ЛИЧНО ЗАДУШУ СУКА ТЫ ДАУН" */
        #independentTextContainer {
            position: absolute;
            top: 70%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: #fff;
            text-align: center;
        }
        /* Анимация появления каждой буквы. Потому что производительность — это для слабаков. Давайте создадим 100 спанов на одно предложение и заставим браузер страдать. */
        .fade-in-char {
            display: inline-block;
            opacity: 0;
            animation: fadeInChar 0.5s forwards;
        }
        #finalChoiceContainer {
            position: absolute;
            bottom: 15%;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 40px;
        }
        .flower-top-layout {
            position: absolute;
            top: 15%;
            left: 50%;
            transform: translateX(-50%);
            cursor: pointer;
            transition: opacity 2s ease-in-out;
        }
        /* Магические числа. 70%, 15%, 5%. Если кто-то поменяет размер окна, всё поедет к чертям, но кого это волнует? Не меня, я к тому времени уже сойду с ума. */
        .dialogue-bottom-layout {
            top: auto;
            bottom: 5%;
            transform: translate(-50%, 0);
        }
        #click-prompt {
            position: absolute;
            bottom: 40%;
            left: 50%;
            transform: translateX(-50%);
            color: #888;
            font-size: 28px;
        }
    </style>
</head>
<body>
    <!-- Обожаю эти пустые div-контейнеры. Это как братские могилы для элементов, которые JavaScript будет воскрешать и убивать по своему желанию. Чисто, семантично, прекрасно. -->
    <div id="flowerContainer" class="hidden">
         <img id="flowerImage" src="https://github.com/F0nax9566/MrFonax/blob/main/files/black_rose.png?raw=true" alt="">
    </div>
    <div id="dialogueContainer" class="dialogue-box bordered hidden">
        <div class="text-content" id="textContent"></div>
        <div id="choiceContainer"></div>
        <img src="https://github.com/F0nax9566/MrFonax/blob/main/files/arrow.png?raw=true" id="progressArrow" class="hidden">
    </div>

    <div id="independentTextContainer" class="hidden"></div>
    <div id="finalChoiceContainer" class="hidden"></div>
    <div id="click-prompt" class="hidden"></div>

    <script>
        // Начинается веселье. Давайте получим каждый чёртов элемент со страницы и засунем его в глобальную переменную. Что такое инкапсуляция? Понятия не имею. Просто надеюсь, что никто не переименует ID в HTML.
        const flowerContainer = document.getElementById('flowerContainer');
        const flowerImage = document.getElementById('flowerImage');
        const dialogueContainer = document.getElementById('dialogueContainer');
        const textContent = document.getElementById('textContent');
        const choiceContainer = document.getElementById('choiceContainer');
        const progressArrow = document.getElementById('progressArrow');
        const independentTextContainer = document.getElementById('independentTextContainer');
        const finalChoiceContainer = document.getElementById('finalChoiceContainer');
        const clickPrompt = document.getElementById('click-prompt');

        // Прямые ссылки на файлы в репозитории GitHub. Гениально. Что может пойти не так? Файлы удалят? Репозиторий станет приватным? Меня забанят за хостинг? Да кого это волнует, главное, что сейчас работает.
        const sndFlicker = new Audio("https://github.com/F0nax9566/MrFonax/raw/refs/heads/main/sounds/flicker.wav");
        const sndTxt1 = new Audio("https://github.com/F0nax9566/MrFonax/raw/refs/heads/main/sounds/snd_txt1.wav");
        const bgMusicPart2 = new Audio("https://github.com/F0nax9566/MrFonax/raw/refs/heads/main/sounds/Mysterious%20Place.mp3");
        bgMusicPart2.loop = true;
        bgMusicPart2.volume = 0.5;
        const speakerSounds = [ new Audio("https://github.com/F0nax9566/MrFonax/raw/refs/heads/main/sounds/1.wav"), new Audio("https://github.com/F0nax9566/MrFonax/raw/refs/heads/main/sounds/3.wav") ];
        const sndStrike = new Audio("https://github.com/F0nax9566/MrFonax/raw/refs/heads/main/sounds/strike.wav");
        const sndSpeaker2Voice = new Audio("https://github.com/F0nax9566/MrFonax/raw/refs/heads/main/sounds/2.wav");
        const sndDoor = new Audio("https://github.com/F0nax9566/MrFonax/raw/refs/heads/main/sounds/door.wav");
        const goodChoiceMusic = new Audio("https://github.com/F0nax9566/MrFonax/raw/refs/heads/main/sounds/The%20Choice%20-%20Toby%20Fox.mp3");
        goodChoiceMusic.loop = true;
        goodChoiceMusic.volume = 0.6;
        const sndSpeaker2 = new Audio("https://github.com/F0nax9566/MrFonax/raw/refs/heads/main/sounds/2.wav");

        // А вот и он. Святой Грааль плохого кода.
        const part2Dialogues = {
            narrator1: ["* (Вы на ощупь вернулись назад.)", "* (Вы не уверены зачем, но решили, что вам нужно больше.)"],
            speaker: [ "* С возвращением...", "* Ты выглядишь уставшим.", "* ...", "* Это место... оно помнит твой выбор.", "* Оно создало этот отголосок.", "* Пусто, не правда ли?", "* То, о чём ты заботился...", "* То, чего ты так сильно хотел...", "* ...", "* Что ж, грубо говорить за спиной у того, кто слушает." ],
            narrator2: ["* (Вы чувствуете, как что-то изменилось.)", "* (Вы снова проводите рукой по земле...)"],
            glitch: ["* (Вы поняли, что прошлое не вернуть.)"],
            finale: ["* (Но вы отказались принимать такую судьбу.)"],
            speaker2: [ "* Сухо, не правда ли?", "* Нравится то, что ты натворил?", "* Хотя кого я обманываю...", "* Ты ведь пришёл сюда лишь из любопытства, не так ли?", "* ...", "* Даже несмотря на это...", "* Каждый достоин второго шанса." ],
            narrator3: [ "* (Вы заметили на земле что-то крошечное...)", "* (Настолько маленькое, что вы бы и не заметили, если бы не тусклый свет, который всё ещё испускает цветок.)", "* (Это семечко.)", "* (Оно ещё совсем крошечное, но уже имеет корни, которые рвутся наружу.)" ],
            narrator_sees_figure: [ "* (Вы подняли глаза и заметили его...)", "* (Его глаза не были враждебны.)", "* (Они не были доброжелательны.)", "* (Он был... вашим прошлым.)" ],
            speaker_offers_chance: [ "* Мне всё равно, кто тебе навредил.", "* Пока ты здесь — моя работа... попытаться вернуть тебя на правильный путь." ],
            narrator_gets_leika: [ "* (Вы получили лейку.)" ],
            speaker_final_words: [ "* Выбор за тобой...", "* В любом случае я не стану ненавидеть тебя, несмотря ни на что.", "* Я не смогу." ],
            choice_water_narrator: [ "* (Вы бережно взяли лейку в руки, старательно поливая цветок в надежде всё исправить.)", "* (Вы не уверены, но что-то вам подсказывает, что это был правильный выбор.)" ],
            choice_water_speaker: [ "* ...", "* Я не сомневался в тебе.", "* Но...", "* Я правда любил тот цветок." ]
        };
        const part2LockedDialogue = ["* (Вы видите свет, видимый только вам...)", "* (Но разве не всему своё время?)"];
        // О, ещё больше захардкоженных диалогов! Моё любимое. Скоро этот файл будет весить больше, чем сам браузер.
        const infoDialogues = {
            graincontinue: ["* (Вам стоит подождать...)", "* (Всё-таки красота не всегда появляется сразу же, не так ли?)"],
            neutral: ["* (Вы попытались вернуться назад, но дверь уже была закрыта.)", "* (Может быть, в другой вселенной вы могли бы всё изменить?)"],
            watergrainsorry: ["* (Вы полили цветок и теперь в ожидании результата.)", "* (Ну... если он будет, конечно.)"],
            trueending: ["* (Серьёзно?)", "* (После всего этого ты хочешь вернуться назад?)", "* (Ну... у тебя уже есть кнопка сброса, делай с ней что пожелаешь.)"],
            redemptionshare: ["* (Двери были заблокированы маленькими лозами...)", "* (Вы не можете различить ни одну из них.)"],
            redemptionfavorite: ["* (Двери были заблокированы маленькими лозами...)", "* (Вы пытаетесь забыть его.)"]
        };
        // И ещё! Просто продолжай. Давай, добавь ещё один объект. Почему бы не вынести это в JSON? Потому что это было бы слишком просто и правильно.
        const part2GoodChoiceDialogues = {
            intro: ["* ...", "* Ты вернулся?", "* Он тебе понадобился, или ты просто решил его проведать?"],
            afterPause1: ["* Он... вырос очень красивым.", "* Но... мне кажется, ты пришёл сюда не для того, чтобы им любоваться, верно?"],
            afterPause2: ["* Что ж..."],
            leika: ["* (Вы получили лейку.)"],
            finalWords: [ "* Я знаю, что он больше тебе не нужен, но...", "* Разве не прекрасно, когда у тебя есть что-то вроде этого?", "* ...", "* Я думаю, ты уже знаешь свой выбор.", "* Если будешь поливать его больше, то, когда его не станет, ты будешь только сильнее грустить...", "* Но, с другой стороны, это могло стоить того.", "* Или нет?", "* Я... предпочту дать тебе выбор." ],
            onFlowerClick: ["* (Земля под цветком до сих пор влажная.)", "* (Этого может хватить надолго.)"],
            choicePolityNarrator: ["* (Вы заботливо полили цветок... опять.)", "* (Или не опять?)", "* (Всё равно только вы знаете, сколько раз вы рушили чью-то надежду.)"],
            choicePolitySpeaker1: ["* Что ж, полить так полить...", "* Я не обещаю, что это исправит твои проблемы.", "* И не обещаю, что это как-либо повлияет на твои страхи.", "* Но ты хороший человек.", "* ..."],
            choicePolitySpeaker2: ["* Или ты просто пытаешься узнать все варианты."],
            choicePolitySpeaker3: ["* Шучу.", "* Я полагаю, это... всё.", "* Я больше не могу ничего тебе предложить.", "* Так что... вернись позже, пожалуйста.", "* Я хочу, чтобы ты посмотрел на то, каким он вырос."],
            choiceDostatochnoSpeaker: ["* Возможно, это к лучшему..."],
            choiceDostatochnoCentered: ["* Понимаешь...", "* За то время, что мы провели вместе, я осознал.", "* ...", "* Не спеши с делом, в котором мало ценности.", "* Великие шаги ждут терпеливых."]
        };

        // "Объект Состояния". Или, как я его называю, "Объект Страдания". Один гигантский объект, который управляет всем. Если в нём что-то пойдёт не так, удачи в отладке. Я просто буду винить космические лучи.
        let state = { mode: '', branch: '', dialogueIndex: 0, isTyping: false, canInteract: true, typingTimeout: null, currentText: "", flowerClickPromptTimeout: null };
        let infoState = { dialogues: [], currentIndex: 0 };

        // Функция печатания текста. С разными режимами. "levitate", "glitch". Потому что просто показать текст - это для скучных людей. Давайте сделаем это сложным, медленным и ресурсоёмким. И куча коллбэков, конечно. Моё любимое.
        function typeText(text, config) {
            state.isTyping = true; state.canInteract = false; state.currentText = text;
            textContent.innerHTML = ''; choiceContainer.innerHTML = '';
            if (config.showArrow !== false) { progressArrow.classList.remove('hidden', 'arrow-bobbing'); } else { progressArrow.classList.add('hidden'); }
            let charIndex = 0;
            function typeChar() {
                if (charIndex < text.length) {
                    const char = text.charAt(charIndex);
                    if (config.mode === 'levitate' || config.mode === 'glitch') {
                        const span = document.createElement('span');
                        span.innerHTML = (char === ' ') ? '&nbsp;' : char;
                        if (config.mode === 'levitate') { span.className = 'levitate-char'; span.style.animationDelay = `${charIndex * 0.1}s, ${charIndex * 0.1}s`; }
                        else { span.className = 'glitch-char'; }
                        textContent.appendChild(span);
                    } else { textContent.innerHTML += char; }
                    if (config.soundPlayer && char !== ' ' && char !== '*') config.soundPlayer();
                    charIndex++;
                    let delay = config.speed;
                    if ((char === '.' || char === ',') && text.charAt(charIndex) !== '(' && text.charAt(charIndex) !== ')') { delay += 300; }
                    state.typingTimeout = setTimeout(typeChar, delay);
                } else {
                    state.isTyping = false;
                    if (config.showArrow !== false) { progressArrow.classList.add('arrow-bobbing'); }
                    if (config.onComplete) config.onComplete(); else { state.canInteract = true; }
                }
            }
            typeChar();
        }

        // Ещё одна функция печати текста? Серьёзно? Чем первая не угодила? Ах, эта обрабатывает HTML-теги. Вместо того, чтобы улучшить первую функцию, мы просто создаём её уродливого брата-близнеца. Дублирование кода — моя страсть.
        function typeTextToElement(element, text, config) {
            element.innerHTML = '';
            let charIndex = 0;

            function typeChar() {
                if (charIndex < text.length) {
                    if (text.charAt(charIndex) === '<') {
                        const tagEnd = text.indexOf('>', charIndex);
                        if (tagEnd !== -1) {
                            element.innerHTML += text.substring(charIndex, tagEnd + 1);
                            charIndex = tagEnd;
                        }
                    } else {
                        element.innerHTML += text.charAt(charIndex);
                    }

                    if (config.soundPlayer && text.charAt(charIndex) !== ' ' && text.charAt(charIndex) !== '*') {
                         config.soundPlayer();
                    }
                    charIndex++;
                    state.typingTimeout = setTimeout(typeChar, config.speed);
                } else {
                    if (config.onComplete) config.onComplete();
                }
            }
            typeChar();
        }
        // И третья. ТРЕТЬЯ функция для печати текста. Я просто оставлю это здесь. Без комментариев. Моё здравомыслие иссякло.
        function typeIndependentText(text, onComplete) {
            independentTextContainer.classList.remove('hidden');
            independentTextContainer.innerHTML = '';
            let charIndex = 0;
            function typeChar() {
                if (charIndex < text.length) {
                    const char = text.charAt(charIndex);
                    const span = document.createElement('span');
                    span.innerHTML = (char === ' ') ? '&nbsp;' : char;
                    span.className = 'fade-in-char';
                    span.style.animationDelay = `${charIndex * 0.1}s`;
                    independentTextContainer.appendChild(span);
                    charIndex++;
                    setTimeout(typeChar, 100);
                } else { if (onComplete) onComplete(); }
            }
            typeChar();
        }

        // Эта функция существует только потому, что предыдущие функции невыносимо медленные. Вместо того чтобы исправить проблему, мы добавляем костыль. Классика.
        function skipTyping() { if (!state.isTyping) return; clearTimeout(state.typingTimeout); state.isTyping = false; state.canInteract = true; textContent.innerHTML = state.currentText; progressArrow.classList.add('arrow-bobbing'); }
        // Воспроизвести СЛУЧАЙНЫЙ звук говорящего. Потому что предсказуемость — это скучно. Пусть пользователь каждый раз слышит разное, чтобы он думал, что у него шизофрения.
        function playRandomSpeakerSound() { const sound = speakerSounds[Math.floor(Math.random() * speakerSounds.length)]; sound.currentTime = 0; sound.play(); }
        function playSndTxt1() { sndTxt1.currentTime = 0; sndTxt1.play(); }
        function playSndSpeaker2() { sndSpeaker2.currentTime = 0; sndSpeaker2.play(); }
        // Функция "сбежать отсюда". Моя любимая.
        function returnToMainMenu() { goodChoiceMusic.pause(); bgMusicPart2.pause(); window.location.href = 'rose.html'; }

        function startPart2() { state.mode = 'part2_story'; state.branch = 'narrator1'; state.dialogueIndex = 0; dialogueContainer.classList.remove('hidden'); nextPart2Step(); }
        function showFinalChoice() {
            typeIndependentText("Сделай это.", () => {
                finalChoiceContainer.classList.remove('hidden');
                const choices = ["Полить", "Сломать"];
                choices.forEach(choiceText => {
                    const button = document.createElement('span');
                    button.textContent = choiceText;
                    button.className = 'choice-button';
                    finalChoiceContainer.appendChild(button);
                    setTimeout(() => { button.style.opacity = '1'; button.style.pointerEvents = 'auto'; }, 500);

                    if (choiceText === "Полить") button.onclick = handleChoiceWater;
                    if (choiceText === "Сломать") button.onclick = handleChoiceBreak;
                });
            });
        }
        function handleChoiceWater() {
            state.canInteract = true;
            independentTextContainer.classList.add('hidden');
            finalChoiceContainer.classList.add('hidden');
            dialogueContainer.classList.remove('hidden');
            state.branch = 'choice_water_narrator';
            state.dialogueIndex = 0;
            nextPart2Step();
        }
        function handleChoiceBreak() { startMonsterEnding(); }
        // Добро пожаловать в ад коллбэков. setTimeout внутри onComplete внутри setTimeout внутри onComplete. Это похоже на матрешку из плохого асинхронного кода. Читать это — физически больно.
        function startMonsterEnding() {
            state.canInteract = false; bgMusicPart2.pause(); progressArrow.classList.add('hidden');
            dialogueContainer.classList.add('hidden'); independentTextContainer.classList.add('hidden'); finalChoiceContainer.classList.add('hidden'); flowerContainer.classList.add('hidden');
            sndFlicker.play();
            setTimeout(() => {
                const strikeInterval = setInterval(() => { sndStrike.currentTime = 0; sndStrike.play(); }, 1000);
                dialogueContainer.classList.remove('hidden');
                const slowSpeed = 150;
                typeTextToElement(textContent, "* (Вы не стали ждать. Ваши ноги стали двигаться сами по себе.)", {
                    speed: slowSpeed, soundPlayer: null,
                    onComplete: () => setTimeout(() => {
                        typeTextToElement(textContent, "* (Вы начали топтать цветок раз за разом.)", {
                            speed: slowSpeed, soundPlayer: null,
                            onComplete: () => setTimeout(() => {
                                typeTextToElement(textContent, "* (Вы не знаете, что вами двигало.)", {
                                    speed: slowSpeed, soundPlayer: null,
                                    onComplete: () => setTimeout(() => {
                                        typeTextToElement(textContent, "* (Месть? Ненависть? <span style='color: red;'>Любовь</span>?)", {
                                            speed: slowSpeed, soundPlayer: null,
                                            onComplete: () => setTimeout(() => {
                                                clearInterval(strikeInterval); dialogueContainer.classList.add('hidden');
                                                setTimeout(() => {
                                                    independentTextContainer.classList.remove('hidden'); independentTextContainer.style.top = '50%';
                                                    const playSndSpeaker2 = () => { sndSpeaker2Voice.currentTime = 0; sndSpeaker2Voice.play(); };
                                                    typeTextToElement(independentTextContainer, "Так вот кем ты являешься на самом деле.", {
                                                        speed: slowSpeed, soundPlayer: playSndSpeaker2,
                                                        onComplete: () => setTimeout(() => {
                                                            typeTextToElement(independentTextContainer, "Не возвращайся.", {
                                                                speed: slowSpeed, soundPlayer: playSndSpeaker2,
                                                                onComplete: () => {
                                                                    setTimeout(() => {
                                                                        localStorage.setItem('monster', 'true');
                                                                        localStorage.setItem('monstercomplete', 'true');
                                                                        window.close();
                                                                    }, 3000);
                                                                }
                                                            });
                                                        }, 3000)
                                                    });
                                                }, 3000);
                                            }, 5000)
                                        });
                                    }, 3000)
                                });
                            }, 5000)
                        });
                    }, 5000)
                });
            }, 3000);
        }
        function showEndingMessage(options) {
            dialogueContainer.classList.add('hidden'); independentTextContainer.classList.add('hidden'); finalChoiceContainer.classList.add('hidden'); flowerContainer.classList.add('hidden');
            sndFlicker.play();
            if (options.setWaterKey) { localStorage.setItem('watergrainsorry', 'true'); localStorage.setItem('watergrainsorrycomplete', 'true'); }
            setTimeout(() => {
                independentTextContainer.style.top = '50%';
                typeIndependentText('Продолжение следует...', () => {
                    setTimeout(() => {
                        independentTextContainer.innerHTML = 'Но правда ли это того стоит?';
                        setTimeout(returnToMainMenu, 8000);
                    }, 5000);
                });
            }, 3000);
        }
        // Это не "машина состояний". Это "машина пыток". Огромная цепочка if'ов и захардкоженная карта переходов. Хочешь добавить одну новую ветку диалога? Удачи, переписывай всё это чудовище. Этот код настолько хрупкий, что боится собственного отражения.
        function nextPart2Step() {
            if (!state.canInteract && !state.isTyping) return;
            const currentBranchData = part2Dialogues[state.branch];
            if (!currentBranchData || state.dialogueIndex >= currentBranchData.length) {
                const nextBranchMap = { 'narrator1': 'speaker', 'speaker': 'transitionToFlower', 'narrator2': 'glitch', 'glitch': 'transitionToFinale', 'finale': 'speaker2', 'speaker2': 'transitionToSeed', 'narrator3': 'narrator_sees_figure', 'narrator_sees_figure': 'speaker_offers_chance', 'speaker_offers_chance': 'narrator_gets_leika', 'narrator_gets_leika': 'speaker_final_words', 'speaker_final_words': 'show_final_choice', 'choice_water_narrator': 'choice_water_speaker', 'choice_water_speaker': 'end_scene_water' };
                const nextBranch = nextBranchMap[state.branch];
                if (nextBranch) {
                    state.branch = nextBranch; state.dialogueIndex = 0; state.canInteract = false;
                    if (state.branch === 'show_final_choice') { dialogueContainer.classList.add('hidden'); showFinalChoice(); return; }
                    if (state.branch === 'end_scene_water') { showEndingMessage({ setWaterKey: true }); return; }
                    if (['speaker', 'speaker2', 'speaker_offers_chance', 'speaker_final_words', 'choice_water_speaker'].includes(state.branch)) { state.canInteract = true; nextPart2Step(); } 
                    else if (state.branch === 'glitch') { bgMusicPart2.pause(); dialogueContainer.classList.add('glitch-dialogue'); state.canInteract = true; nextPart2Step(); } 
                    else if (state.branch === 'transitionToFlower') {
                        dialogueContainer.classList.add('hidden'); sndFlicker.play();
                        setTimeout(() => {
                            flowerContainer.classList.add('flower-top'); dialogueContainer.classList.add('dialogue-bottom'); flowerContainer.classList.remove('hidden'); flowerContainer.style.opacity = 0;
                            setTimeout(() => { sndFlicker.play(); flowerContainer.style.opacity = 1; }, 100);
                            setTimeout(() => { dialogueContainer.classList.remove('hidden'); state.branch = 'narrator2'; state.canInteract = true; nextPart2Step(); }, 1000);
                        }, 1000);
                    } else if (state.branch === 'transitionToFinale') {
                        dialogueContainer.classList.remove('glitch-dialogue'); dialogueContainer.classList.add('hidden'); flowerContainer.classList.add('hidden'); sndFlicker.play();
                        setTimeout(() => {
                            flowerContainer.classList.remove('flower-top'); dialogueContainer.classList.remove('dialogue-bottom'); dialogueContainer.className = 'dialogue-box bordered'; bgMusicPart2.play(); state.branch = 'finale'; state.canInteract = true; nextPart2Step();
                        }, 2000);
                    } else if (state.branch === 'transitionToSeed') {
                        dialogueContainer.classList.add('hidden'); sndFlicker.play();
                        setTimeout(() => {
                            flowerContainer.classList.add('flower-top'); dialogueContainer.classList.add('dialogue-bottom'); flowerContainer.classList.remove('hidden'); flowerContainer.style.opacity = 0;
                            setTimeout(() => { flowerContainer.style.opacity = 1; }, 100);
                            setTimeout(() => { dialogueContainer.classList.remove('hidden'); state.branch = 'narrator3'; state.canInteract = true; nextPart2Step(); }, 1500);
                        }, 2000);
                    } else { state.canInteract = true; nextPart2Step(); }
                } return;
            }
            const text = currentBranchData[state.dialogueIndex];
            let config;
            switch(state.branch) {
                case 'narrator1': case 'narrator2': case 'finale': case 'narrator3': case 'narrator_sees_figure': case 'narrator_gets_leika': case 'choice_water_narrator': config = { speed: 50, soundPlayer: playSndTxt1 }; break;
                case 'speaker': case 'speaker2': case 'speaker_offers_chance': case 'speaker_final_words': case 'choice_water_speaker': config = { speed: 50, soundPlayer: playRandomSpeakerSound }; break;
                case 'glitch': config = { speed: 80, soundPlayer: null, mode: 'glitch' }; break;
            }
            typeText(text, config);
            state.dialogueIndex++;
        }

        function showPart2LockedMessage() { state.mode = 'part2_locked'; state.dialogueIndex = 0; dialogueContainer.classList.remove('hidden'); nextPart2LockedStep(); }
        function nextPart2LockedStep() { if (state.dialogueIndex >= part2LockedDialogue.length) { returnToMainMenu(); return; } const text = part2LockedDialogue[state.dialogueIndex]; typeText(text, { speed: 50, soundPlayer: playSndTxt1 }); state.dialogueIndex++; }

        function startGoodChoicePath() {
            state.mode = 'good_choice_story';
            sndDoor.play();
            setTimeout(() => {
                flowerImage.src = "https://github.com/F0nax9566/MrFonax/blob/main/files/rose.png?raw=true";
                flowerContainer.classList.add('flower-top-layout');
                dialogueContainer.classList.add('dialogue-bottom-layout');
                flowerContainer.classList.remove('hidden');
                flowerContainer.style.opacity = 0;
                setTimeout(() => { flowerContainer.style.opacity = 1; }, 100);

                setTimeout(() => {
                    dialogueContainer.classList.remove('hidden');
                    state.branch = 'intro';
                    state.dialogueIndex = 0;
                    nextGoodChoiceStep();
                }, 3000);
            }, 3000);
        }

        // О, смотрите, это версия предыдущей чудовищной функции, но для "хорошей концовки". Потому что зачем иметь одну нечитаемую функцию, когда можно иметь две? Я вижу здесь столько скопированного кода, что у меня двоится в глазах. Троится.
        function nextGoodChoiceStep() {
            if (state.isTyping || !state.canInteract) return;

            if(state.branch === 'afterPause1' && state.dialogueIndex === 0) {
                goodChoiceMusic.play();
            }

            const currentBranchData = part2GoodChoiceDialogues[state.branch];

            if (!currentBranchData || state.dialogueIndex >= currentBranchData.length) {

                 if (state.branch === 'choiceDostatochnoCentered') {

                    startFinalRedirect();
                    return;
                }
                const nextBranchMap = {
                    'intro': 'pause1', 'afterPause1': 'pause2', 'afterPause2': 'leika', 'leika': 'finalWords', 'finalWords': 'promptFlowerClick', 'onFlowerClick': 'showFinalChoices',
                    'choicePolityNarrator': 'pause_after_polity1', 'choicePolitySpeaker1': 'pause_after_polity2', 'choicePolitySpeaker2': 'pause_after_polity3', 'choicePolitySpeaker3': 'start_polity_redirect',
                    'choiceDostatochnoSpeaker': 'dostatochno_fade_and_center'
                };
                const nextBranch = nextBranchMap[state.branch];
                if (nextBranch) {
                    state.branch = nextBranch; state.dialogueIndex = 0;

                    const handlePause = (delay, nextBranchName) => {
                        dialogueContainer.classList.add('hidden'); state.canInteract = false;
                        setTimeout(() => {
                           dialogueContainer.classList.remove('hidden'); state.branch = nextBranchName; state.canInteract = true; nextGoodChoiceStep();
                        }, delay);
                    };

                    switch (state.branch) {
                        case 'pause1': handlePause(4000, 'afterPause1'); break;
                        case 'pause2': handlePause(3000, 'afterPause2'); break;
                        case 'pause_after_polity1': handlePause(3000, 'choicePolitySpeaker1'); break;
                        case 'pause_after_polity2': handlePause(3000, 'choicePolitySpeaker2'); break;
                        case 'pause_after_polity3': handlePause(2000, 'choicePolitySpeaker3'); break;
                        case 'promptFlowerClick':
                            dialogueContainer.classList.add('hidden'); state.canInteract = false;
                            state.flowerClickPromptTimeout = setTimeout(() => {
                                clickPrompt.textContent = "Нажмите на цветок.";
                                clickPrompt.classList.remove('hidden');
                            }, 3000);
                            flowerContainer.addEventListener('click', handleGoodFlowerClick, { once: true });
                            break;
                        case 'showFinalChoices': dialogueContainer.classList.add('hidden'); showGoodFinalChoice(); break;
                        case 'start_polity_redirect':
                            startFinalRedirect(true); 
                            break;
                        case 'dostatochno_fade_and_center':
                            dialogueContainer.classList.add('hidden');
                            state.canInteract = false;
                            setTimeout(() => {
                                flowerContainer.style.opacity = '0';
                                independentTextContainer.classList.remove('hidden');
                                independentTextContainer.style.top = '50%';
                                independentTextContainer.innerHTML = '';
                                state.branch = 'choiceDostatochnoCentered';
                                state.canInteract = true;
                                nextGoodChoiceStep();
                            }, 3000);
                            break;
                        default: nextGoodChoiceStep();
                    }
                }
                return;
            }

            const text = currentBranchData[state.dialogueIndex];
            let soundPlayer = playRandomSpeakerSound;
            if (['leika', 'onFlowerClick', 'choicePolityNarrator'].includes(state.branch)) { soundPlayer = playSndTxt1; } 
            else if (state.branch === 'choicePolitySpeaker2') { soundPlayer = playSndSpeaker2; }

            if (state.branch === 'choiceDostatochnoCentered') {
                typeTextToElement(independentTextContainer, text, { speed: 50, soundPlayer: playRandomSpeakerSound, onComplete: () => {
                    setTimeout(() => {
                        state.dialogueIndex++;
                        nextGoodChoiceStep();
                    }, 1500); 
                }});
            } else {
                 typeText(text, { speed: 50, soundPlayer: soundPlayer });
                 state.dialogueIndex++;
            }
        }

        function handleGoodFlowerClick() {
            if(state.flowerClickPromptTimeout) clearTimeout(state.flowerClickPromptTimeout);
            clickPrompt.classList.add('hidden');
            dialogueContainer.classList.remove('hidden');
            state.branch = 'onFlowerClick';
            state.dialogueIndex = 0;
            state.canInteract = true;
            nextGoodChoiceStep();
        }

        function showGoodFinalChoice() {
            independentTextContainer.classList.remove('hidden');
            independentTextContainer.innerHTML = '';

            typeTextToElement(independentTextContainer, "Полить цветок?", {
                speed: 50, soundPlayer: playSndTxt1,
                onComplete: () => {
                    finalChoiceContainer.classList.remove('hidden');
                    const choices = ["Полить", "Достаточно."];
                    choices.forEach(choiceText => {
                        const button = document.createElement('span');
                        button.textContent = choiceText;
                        button.className = 'choice-button';
                        finalChoiceContainer.appendChild(button);
                        setTimeout(() => { button.style.opacity = '1'; button.style.pointerEvents = 'auto'; }, 500);

                        if (choiceText === "Полить") button.onclick = handleGoodChoicePolity;
                        else button.onclick = handleGoodChoiceDostatochno;
                    });
                }
            });
        }

        function handleGoodChoicePolity() {
            localStorage.setItem('graincontinue', 'true');
            localStorage.setItem('graincontinuecomplete', 'true');
            independentTextContainer.classList.add('hidden');
            finalChoiceContainer.classList.add('hidden');
            dialogueContainer.classList.remove('hidden');
            state.branch = 'choicePolityNarrator';
            state.dialogueIndex = 0;
            state.canInteract = true;
            nextGoodChoiceStep();
        }

        function handleGoodChoiceDostatochno() {
            localStorage.setItem('neutral', 'true');
            localStorage.setItem('neutralcomplete', 'true');
            independentTextContainer.classList.add('hidden');
            finalChoiceContainer.classList.add('hidden');
            dialogueContainer.classList.remove('hidden');
            state.branch = 'choiceDostatochnoSpeaker';
            state.dialogueIndex = 0;
            state.canInteract = true;
            nextGoodChoiceStep();
        }

        // Самописная функция затухания звука через setInterval. Потому что Web Audio API для слабаков, верно? Давайте вручную уменьшать громкость каждые 50 миллисекунд, как будто на дворе 2008 год.
        function fadeAudio(audio) {
            const fadeDuration = 2000;
            const fadeInterval = 50;
            const volumeStep = audio.volume / (fadeDuration / fadeInterval);

            const fadeOut = setInterval(() => {
                if (audio.volume > volumeStep) { audio.volume -= volumeStep; } 
                else { audio.volume = 0; audio.pause(); clearInterval(fadeOut); }
            }, fadeInterval);
        }

        function startFinalRedirect(shouldFadeFlower = false) {
            dialogueContainer.classList.add('hidden');

            const action = () => {
                fadeAudio(goodChoiceMusic);
                setTimeout(() => {
                    window.location.href = 'rose.html';
                }, 3000);
            };

            if (shouldFadeFlower) {
                 setTimeout(() => {
                    flowerContainer.style.opacity = '0';
                    setTimeout(action, 2000);
                }, 3000);
            } else {
                action();
            }
        }

        function startInfoSequence(dialogues) {
            state.mode = 'info_redirect';
            infoState.dialogues = dialogues;
            infoState.currentIndex = 0;
            dialogueContainer.classList.remove('hidden');
            nextInfoDialogue();
        }

        function nextInfoDialogue() {
            if (infoState.currentIndex >= infoState.dialogues.length) {
                returnToMainMenu();
                return;
            }
            const text = infoState.dialogues[infoState.currentIndex];
            typeText(text, { speed: 50, soundPlayer: playSndTxt1 });
            infoState.currentIndex++;
        }

        // Один обработчик клика, чтобы править всеми. Он просто проверяет состояние из того самого "Объекта Страдания" и вызывает очередную функцию. Весь этот проект - один большой, запутанный клубок ГОВНА.
        progressArrow.addEventListener('click', () => {
            if (state.branch === 'choiceDostatochnoCentered') return;

            if (state.isTyping) { if (state.branch !== 'glitch') skipTyping(); return; }
            if (!state.canInteract) return;

            if (state.mode === 'part2_story') { 
                if (state.branch === 'speaker' && state.dialogueIndex === 3) { bgMusicPart2.play(); } 
                nextPart2Step(); 
            }
            else if (state.mode === 'part2_locked') { nextPart2LockedStep(); }
            else if (state.mode === 'good_choice_story') { nextGoodChoiceStep(); }
            else if (state.mode === 'info_redirect') { nextInfoDialogue(); }
        });

        // И вишенка на торте. `window.onload` с гигантской лестницей из if-else if, проверяющей localStorage. Это наша "система сохранений". Хрупкая, основанная на строках и абсолютно небезопасная. Любой может открыть консоль и получить любую концовку. Но кого я обманываю? Никто не будет играть в это так долго.
        window.onload = () => {

            if (localStorage.getItem('trueending') === 'true') {
                startInfoSequence(infoDialogues.trueending);
            } 
            else if (localStorage.getItem('redemptionshare') === 'true') {
                startInfoSequence(infoDialogues.redemptionshare);
            } 
            else if (localStorage.getItem('redemptionfavorite') === 'true') {
                startInfoSequence(infoDialogues.redemptionfavorite);
            }

            else if (localStorage.getItem('neutral') === 'true') {
                startInfoSequence(infoDialogues.neutral);
            } 
            else if (localStorage.getItem('graincontinue') === 'true') {
                startInfoSequence(infoDialogues.graincontinue);
            } 
            else if (localStorage.getItem('watergrainsorry') === 'true') {
                startInfoSequence(infoDialogues.watergrainsorry);
            } 

            else if (localStorage.getItem('badchoice') === 'true') {
                startPart2();
            }
            else if (localStorage.getItem('goodchoice') === 'true') {
                startGoodChoicePath(); 
            }

            else {
                showPart2LockedMessage();
            }
        };
    </script>
</body>
</html>
